<!DOCTYPE html>
<html>
	<head>
		<title>Starks | Het softwareontwikkelingsproces</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>
		<link href='http://fonts.googleapis.com/css?family=Roboto:400,400italic,700' rel='stylesheet' type='text/css'>
		<link href="../../css/main.css" rel="stylesheet">
	</head>

	<body cz-shortcut-listen = "true">
		
			<nav class="navbar navbar-default">
			<div class="container">
				<a href="analyse_I.html" class="navbar-brand">Analyse I</a>
				<p class="navbar-text navbar-right"><a href="../../index.html" class="navbar-link"></a></p>
			</div>
			</nav>
			<div class="container">
			<section>
				<h1 >Het softwareontwikkelingsproces</h1>
					<article>
						<h2 id="softwarecrisis">De software crisis</h2>
						<p>
							In het boek, <em>"The Mythical Man-Month"</em> beschrijft Frederick Brooks een wet die later bekend werd als Brooks' Law:<br>
							<em><strong>"Adding manpower to a late software project makes it later"</strong></em><br>
							Brooks zegt zelf dat dit een simplificatie van het probleem is, maar wijst toch op twee erg belangrijke zaken:
						</p>

						<ol>
							<li>
								Het duurt even alvorens mensen die nieuw in een project toekomen productief worden. Software projecten zijn complexe ondernemeningen en nieuwe projectmedewerkers moeten zich eerst een lange tijd inwerken alvorens ze mee zijn met het project zonder dat ze gedurende die periode een toegevoegde waarde kunnen leveren. Ook moeten de bestaande werkers tijd investeren in de nieuwe aangenomen projectmedewerkers. Daarenboven kan een nieuwe medewerker (daarom niet moedwillig) bugs introduceren in de code waar (i) lang naar toe kan gezocht worden en (ii) lang aan kan gewerkt worden om ze op te lossen.
							</li>

							<li>
								Communiceren wordt erg moeilijk: het aantal mogelijke communicatiemogelijkheden stijgt polynomiaal bij het toevoegen van nieuwe medewerkers.
							</li>
						</ol>

						<p>
							Blijkbaar helpt het toevoegen van meer mankracht in een project niet. De oorzaak van het falen van de projecten ligt dus blijkbaar ergens anders.
						</p>
					</article>

					<article>
						<h2 id="oorzakenSoft">Oorzaken software crisis</h2>
						<p>
							Er zijn twee soorten problemen die je kan tegen komen in de ontwikkeling van software:
						</p>

						<ul>
							<li>Tamme problemen</li>
							<li>Gemene problemen (wicked problems)</li>
						</ul>
					</article>

					<article>
						<h3 id="tammeProblemen">Tamme problemen</h3>
						<p>
							Tamme problemen zijn stabiele en goed gedefinieerde problemen. Vaak zijn deze problemen goed afgebakend en is er een pasklare oplossing.
						</p>

						<p>Denk hierbij bijvoorbeeld aan:</p>
						<ul>
							<li>Hardware problemen</li>
							<li>Ziekte van een werknemer</li>
							<li>Tijdelijk uitvallen van netwerk</li>
							<li>...</li>
						</ul>
					</article>

					<article>
						<h3 id="wickedProblemen">Wicked problems</h3>
						<p>
							Wicked problemen daarentegen zijn vaag, je snapt pas het probleem eenmaal de oplossing ervoor geformuleerd is. Het is vaak onduidelijk wanneer ze opgelost zijn en ze zijn uniek voor de omgeving waarin je werkt.<br>
							Denk hierbij aan:
						</p>
						<ul>
							<li>Veranderende wens van de klant</li>
							<li>Introductie van nieuwe technologie&euml;n die je midden ontwikkeling zou willen gebruiken.</li>
							<li>...</li>
						</ul>
					</article>

					<article>
						<h3 id="clients">One wicked problem: <strong>clients</strong></h3>
						<p>
							Een groot wicked probleem is dat de opdrachtgevers vaak zelf niet goed weten wat ze willen. Of zoals Brooks het vermeldt:
						</p>

						<p><em>
							"For the truth is, the clients do not know what they want. They usually do not know what question must be answered, and they almost never have thought of the problem in the detail that must be specified/"
						</em></p>

						<p>
							En Jeff Atwood
						</p>

						<p><em>
							"In software, we rarely have meaningful requirements. Even if we do, the only measure of succes that matters is whether our solution solves the customer's shifting idea of what their problem is."
						</em></p>

						<p>
							We moeten dus een manier vinden om met de wisselende wensen van de opdrachtgever om te gaan.
						</p>
					</article>

					<article>
						<h2>Softwareontwikkelingsproces</h2>
						<p>
							Als beginnende ontwikkelaar van software ga je vaak de fout maken dat je onmiddelijk zou willen programmeren. Je kent makkelijk een aantal programmeertalen en leuke technische snufjes die je zou willen toepassen. Maar dit zou je gedurende het proces zuur komen te staan.
						</p>

						<p>
							Het beter enkele vragen eerst te stellen, alvorens je de IDE erbij neemt.
						</p>

						<ul>
							<li>Waar moet ik starten?</li>
							<li>Hoe moet ik er aan beginnen?</li>
							<li>Wat daarna?</li>
						</ul>

						<p>
							Het antwoord op deze vragen is het volgen van een softwareontwikkelproces. Een ontwikkelproces structureert je project zodat je bepaalde taken stap voor stap kan uitvoeren en je niet in 10 verschillende richtingen tegelijk werkt en alles in 1 keer klaar wilt hebben. Een proces is een workflow die de volgorde vastlegt waarin je de dingen doet in een software project.
						</p>

						<p>
							Formeel kan je het softwareontwikkelproces als volgt defini&euml;ren:
						</p>

						<p>
							<strong>Definitie:</strong><br>
							<em>
								Het softwareontwikkelproces is een kader dat vastlegt hoe een softwareproject wordt aangepakt en een methode om de activiteiten in verband met creatie, oplevering en onderhoud van softwaresystemen te organiseren.
							</em>
						</p>
					</article>

					<article>
						<h2>Onderdelen van een SOOP</h2>
						<p>
							Je kan verschillende onderdelen onderscheiden bij het softwareontwikkelingsproces:
						</p>

						<ol>
							<li>De analyse</li>
							<li>Het ontwerp</li>
							<li>Implementatiefase</li>
							<li>TestFase</li>
							<li>Integratie</li>
							<li>Onderhoudsfase</li>
						</ol>

						<p>
							In wat volgt beschrijven we deze fasen kort:
						</p>
					</article>

					<article>
						<h3>Analyse</h3>
						<p>
							De studie en de beschrijving van het probleem: we moeten achterhalen wat het systeem moet doen en wat de randvoorwaarden zijn. We zorgen ervoor dat het probleem vertaald wordt in een taal die zowel verstaanbaar is voor de klant, als voor de mensen die het eigenlijk ontwerpen en implementeren voor zich zullen nemen. De analyse kan verschillende componenten omvatten. We noemen er hier een aantal op en zullen verder doorheen de cursus verduidelijkt worden. 
						</p>

						<ul>
							<li>Use Cases (UC)</li>
							<li>User stories</li>
							<li>Opmaken van een domeinmodel</li>
							<li>Sequentiediagrammen</li>
							<li>...</li>
						</ul>

						<p>
							Er moet gelet worden dat de software:
						</p>

						<ul>
							<li>voldoet aan de taken en functies beschreven in de Use Cases en functionele specificaties</li>
							<li>voldoet aan alle technische vereisten</li>
							<li>eenvoudig aan te passen is wanneer functionele eisen wijzigen</li>
						</ul>
					</article>

					<article>
						<h3>Ontwerp</h3>
						<p>
							Deze fase omvat het specificeren van de nodige onderdelen van het te bouwen systeem: welke componenten zijn er nodig, kan ik hergebruiken en hoe werken die samen met elkaar. Het ontwerpmodel dient als abstractie van de broncode; het is een (gedetailleerd) plan dat beschrijft hoe de broncode wordt gestructureerd en geschreven. Het ontwerpmodel bestaat uit klassen, gestructureerd in modules en subsystemen, met duidelijk beschreven interfaces. Het bevat ook de beschrijving over hoe deze klassen met elkaar samenwerken.
						</p>
					</article>

					<article>
						<h3>Implementeren</h3>
						<p>
							Dit is eigenlijke coderen van het systeem: we vertellen in een taal verstaanbaar voor de computer hoe die de verschillende functies moet uitvoeren. Hierin komt naar voor:

							<ul>
								<li>Het vastleggen van de organisatie van de broncode;</li>
								<li>Het implementeren van subsystemen;</li>
								<li>het vastleggen van klassen en objecten;</li>
								<li>Het testen van de ontwikkelde componenten (Unittesten)</li>
								<li>Het integreren van de resultaten van individuen tot een systeem</li>
							</ul>
						</p>
					</article>

					<article>
						<h3>Testen &amp; Valideren</h3>
						<p>
							In de analysefase worden een aantal testscenario's opgemaakt. In de testfase gaan we dus na of de software werkt en verwacht aan de verwachtingen van de klant. Hier komt naar voor:
						</p>

						<ul>
							<li>Het controleren van de interactie tussen verschillende object;</li>
							<li>Het controleren van de integratie van verschillende componenten;</li>
							<li>Het controleren van het systeem om te kijken of alle requirements juist zijn ge&iuml;mplementeerd;</li>
							<li>Het in kaart brengen en prioritiseren van defecten.</li>
						</ul>
					</article>

					<article>
						<h3>Integratie</h3>
						<p>
							
						</p>
					</article>
			</section>

			<ol class="breadcrumb">
				<li><a href="analyse_I.html">Analyse I</a></li>
				<li class="active">De software crisis</li>
			</ol>
		<div>
	</body>
</html>