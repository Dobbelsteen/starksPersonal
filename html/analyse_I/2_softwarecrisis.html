<!DOCTYPE html>
<html>
	<head>
		<title>Starks | Het softwareontwikkelingsproces</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>
		<link href='http://fonts.googleapis.com/css?family=Roboto:400,400italic,700' rel='stylesheet' type='text/css'>
		<link href="../../css/main.css" rel="stylesheet">
	</head>

	<body cz-shortcut-listen = "true">
		
			<nav class="navbar navbar-default">
			<div class="container">
				<a href="analyse_I.html" class="navbar-brand">Analyse I</a>
				<p class="navbar-text navbar-right"><a href="../../index.html" class="navbar-link"></a></p>
			</div>
			</nav>
			<div class="container">
			<section>
				<h1 >Het softwareontwikkelingsproces</h1>
					<article>
						<h2 id="softwarecrisis">De software crisis</h2>
						<p>
							In het boek, <em>"The Mythical Man-Month"</em> beschrijft Frederick Brooks een wet die later bekend werd als Brooks' Law:<br>
							<em><strong>"Adding manpower to a late software project makes it later"</strong></em><br>
							Brooks zegt zelf dat dit een simplificatie van het probleem is, maar wijst toch op twee erg belangrijke zaken:
						</p>

						<ol>
							<li>
								Het duurt even alvorens mensen die nieuw in een project toekomen productief worden. Software projecten zijn complexe ondernemeningen en nieuwe projectmedewerkers moeten zich eerst een lange tijd inwerken alvorens ze mee zijn met het project zonder dat ze gedurende die periode een toegevoegde waarde kunnen leveren. Ook moeten de bestaande werkers tijd investeren in de nieuwe aangenomen projectmedewerkers. Daarenboven kan een nieuwe medewerker (daarom niet moedwillig) bugs introduceren in de code waar (i) lang naar toe kan gezocht worden en (ii) lang aan kan gewerkt worden om ze op te lossen.
							</li>

							<li>
								Communiceren wordt erg moeilijk: het aantal mogelijke communicatiemogelijkheden stijgt polynomiaal bij het toevoegen van nieuwe medewerkers.
							</li>
						</ol>

						<p>
							Blijkbaar helpt het toevoegen van meer mankracht in een project niet. De oorzaak van het falen van de projecten ligt dus blijkbaar ergens anders.
						</p>
					</article>

					<article>
						<h2 id="oorzakenSoft">Oorzaken software crisis</h2>
						<p>
							Er zijn twee soorten problemen die je kan tegen komen in de ontwikkeling van software:
						</p>

						<ul>
							<li>Tamme problemen</li>
							<li>Gemene problemen (wicked problems)</li>
						</ul>
					</article>

					<article>
						<h3 id="tammeProblemen">Tamme problemen</h3>
						<p>
							Tamme problemen zijn stabiele en goed gedefinieerde problemen. Vaak zijn deze problemen goed afgebakend en is er een pasklare oplossing.
						</p>

						<p>Denk hierbij bijvoorbeeld aan:</p>
						<ul>
							<li>Hardware problemen</li>
							<li>Ziekte van een werknemer</li>
							<li>Tijdelijk uitvallen van netwerk</li>
							<li>...</li>
						</ul>
					</article>

					<article>
						<h3 id="wickedProblemen">Wicked problems</h3>
						<p>
							Wicked problemen daarentegen zijn vaag, je snapt pas het probleem eenmaal de oplossing ervoor geformuleerd is. Het is vaak onduidelijk wanneer ze opgelost zijn en ze zijn uniek voor de omgeving waarin je werkt.<br>
							Denk hierbij aan:
						</p>
						<ul>
							<li>Veranderende wens van de klant</li>
							<li>Introductie van nieuwe technologie&euml;n die je midden ontwikkeling zou willen gebruiken.</li>
							<li>...</li>
						</ul>
					</article>

					<article>
						<h3 id="clients">One wicked problem: <strong>clients</strong></h3>
						<p>
							Een groot wicked probleem is dat de opdrachtgevers vaak zelf niet goed weten wat ze willen. Of zoals Brooks het vermeldt:
						</p>

						<p><em>
							"For the truth is, the clients do not know what they want. They usually do not know what question must be answered, and they almost never have thought of the problem in the detail that must be specified/"
						</em></p>

						<p>
							En Jeff Atwood
						</p>

						<p><em>
							"In software, we rarely have meaningful requirements. Even if we do, the only measure of succes that matters is whether our solution solves the customer's shifting idea of what their problem is."
						</em></p>

						<p>
							We moeten dus een manier vinden om met de wisselende wensen van de opdrachtgever om te gaan.
						</p>
					</article>

					<article>
						<h2>Softwareontwikkelingsproces</h2>
						<p>
							Als beginnende ontwikkelaar van software ga je vaak de fout maken dat je onmiddelijk zou willen programmeren. Je kent makkelijk een aantal programmeertalen en leuke technische snufjes die je zou willen toepassen. Maar dit zou je gedurende het proces zuur komen te staan.
						</p>

						<p>
							Het beter enkele vragen eerst te stellen, alvorens je de IDE erbij neemt.
						</p>

						<ul>
							<li>Waar moet ik starten?</li>
							<li>Hoe moet ik er aan beginnen?</li>
							<li>Wat daarna?</li>
						</ul>

						<p>
							Het antwoord op deze vragen is het volgen van een softwareontwikkelproces. Een ontwikkelproces structureert je project zodat je bepaalde taken stap voor stap kan uitvoeren en je niet in 10 verschillende richtingen tegelijk werkt en alles in 1 keer klaar wilt hebben. Een proces is een workflow die de volgorde vastlegt waarin je de dingen doet in een software project.
						</p>

						<p>
							Formeel kan je het softwareontwikkelproces als volgt defini&euml;ren:
						</p>

						<p>
							<strong>Definitie:</strong><br>
							<em>
								Het softwareontwikkelproces is een kader dat vastlegt hoe een softwareproject wordt aangepakt en een methode om de activiteiten in verband met creatie, oplevering en onderhoud van softwaresystemen te organiseren.
							</em>
						</p>
					</article>

					<article>
						<h2>Onderdelen van een SOOP</h2>
						<p>
							Je kan verschillende onderdelen onderscheiden bij het softwareontwikkelingsproces:
						</p>

						<ol>
							<li>De analyse</li>
							<li>Het ontwerp</li>
							<li>Implementatiefase</li>
							<li>TestFase</li>
							<li>Integratie</li>
							<li>Onderhoudsfase</li>
						</ol>

						<p>
							In wat volgt beschrijven we deze fasen kort:
						</p>
					</article>

					<article>
						<h3>Analyse</h3>
						<p>
							De studie en de beschrijving van het probleem: we moeten achterhalen wat het systeem moet doen en wat de randvoorwaarden zijn. We zorgen ervoor dat het probleem vertaald wordt in een taal die zowel verstaanbaar is voor de klant, als voor de mensen die het eigenlijk ontwerpen en implementeren voor zich zullen nemen. De analyse kan verschillende componenten omvatten. We noemen er hier een aantal op en zullen verder doorheen de cursus verduidelijkt worden. 
						</p>

						<ul>
							<li>Use Cases (UC)</li>
							<li>User stories</li>
							<li>Opmaken van een domeinmodel</li>
							<li>Sequentiediagrammen</li>
							<li>...</li>
						</ul>

						<p>
							Er moet gelet worden dat de software:
						</p>

						<ul>
							<li>voldoet aan de taken en functies beschreven in de Use Cases en functionele specificaties</li>
							<li>voldoet aan alle technische vereisten</li>
							<li>eenvoudig aan te passen is wanneer functionele eisen wijzigen</li>
						</ul>
					</article>

					<article>
						<h3>Ontwerp</h3>
						<p>
							Deze fase omvat het specificeren van de nodige onderdelen van het te bouwen systeem: welke componenten zijn er nodig, kan ik hergebruiken en hoe werken die samen met elkaar. Het ontwerpmodel dient als abstractie van de broncode; het is een (gedetailleerd) plan dat beschrijft hoe de broncode wordt gestructureerd en geschreven. Het ontwerpmodel bestaat uit klassen, gestructureerd in modules en subsystemen, met duidelijk beschreven interfaces. Het bevat ook de beschrijving over hoe deze klassen met elkaar samenwerken.
						</p>
					</article>

					<article>
						<h3>Implementeren</h3>
						<p>
							Dit is eigenlijke coderen van het systeem: we vertellen in een taal verstaanbaar voor de computer hoe die de verschillende functies moet uitvoeren. Hierin komt naar voor:

							<ul>
								<li>Het vastleggen van de organisatie van de broncode;</li>
								<li>Het implementeren van subsystemen;</li>
								<li>het vastleggen van klassen en objecten;</li>
								<li>Het testen van de ontwikkelde componenten (Unittesten)</li>
								<li>Het integreren van de resultaten van individuen tot een systeem</li>
							</ul>
						</p>
					</article>

					<article>
						<h3>Testen &amp; Valideren</h3>
						<p>
							In de analysefase worden een aantal testscenario's opgemaakt. In de testfase gaan we dus na of de software werkt en verwacht aan de verwachtingen van de klant. Hier komt naar voor:
						</p>

						<ul>
							<li>Het controleren van de interactie tussen verschillende object;</li>
							<li>Het controleren van de integratie van verschillende componenten;</li>
							<li>Het controleren van het systeem om te kijken of alle requirements juist zijn ge&iuml;mplementeerd;</li>
							<li>Het in kaart brengen en prioritiseren van defecten.</li>
						</ul>
					</article>

					<article>
						<h3>Integratie</h3>
						<p>
							Indien het systeem moet samenwerken met andere bestaande componenten of systemen, zal dat gebeuren in de integratiefase. Natuurlijk zal hier ook een test en validatiemoment moeten ingelast worden.
						</p>
					</article>

					<article>
						<h3>Onderhoud</h3>
						<p>
							Eenmaal de software af is, kunnen er nog wijzigingen doorgevoerd worden ten behoeve van veranderende eisen van de klant of vanuit een andere omgeving.
						</p>
					</article>

					<article>
						<h2>Watervalmethode</h2>
						<p>
							Een eerste ontwikkelproces is de watervalmethode, bij de watervalmethode volgt de ene stap na de andere. De eerste stap moet volledig zijn afgerond alvorens aan de volgende kan worden gestart en er is geen weg terug. Elke fase voorziet cruciale activiteit(en), de fasen zelf zijn georganiseerd in een sequenti&euml;le en lineaire ordening waarbij elke fase volledig moet be&euml;indigd zijn voor de volgende kan aangevangen worden. De uitvoer van die fasen wordt gebruikt als invoer voor de volgende. Dit is het oudste ontwikkelproces : goed voor wel gekende systemen met weinig problemen en stabiele requirements. Maar dit is zelden het geval.
						</p>
						<p>
							Nadelen hiervan zijn:
						</p>
						<ul>
							<li>
								<b>Geen flexibiliteit</b>: omdat de ontwikelfasen zo definitief zijn, gaan analisten, ontwerpers en ontwikkelaars behoedzaam te werk. Er is geen weg terug en dus moet het op te leveren werk volledig correct zijn. Dit voorkomt dat er nieuwe wensen en eisen ontstaan tijdens een project.
							</li>
							<li>
								<b>Verlies van informatie</b>: zodra een ontwerper klaas is met zijn fase gaat de ontwikkelaar ermee aan de slag. In de meeste projecten is dit het moment waarop de ontwerper het project verlaat. En als is hetij nog grondig te werk gegaan, nooit is alles compleet. De meeste kennis zit in het hoofd van de ontwerper en deze kennis zal op dat moment niet meer voorhanden zijn.
							</li>
							<li>
								<b>Testen als sluitpost</b>: pas als de applicatie door de ontwikkelaars is opgeleverd wordt er getest. Probleem: naarmate een fout later in het project wordt ontdekt, nemen de kosten voor het oplossen van de fout functioneel toe. Het is belangrijk fouten zo vroeg mogelijk te detecteren.
							</li>
						</ul>
					</article>

					<article>
						<h2>Iteratief en incrementeel werken: <strong>Agile</strong></h2>
						<p>
							Bij iteratief benaderen is er ook een weg terug. Agile software ontwikkeling is een conceptueel raamwerk voor het uitvoeren van softwareontwikkelingsprojecten als alternatief voor traditionele starre praktrijken. Het Engelse woord <b>Agile</b> betekent: begendig, lenig, ... De omslag heeft plaats gevonden vanwege de vele tekortkomingen die zich voor doen in de waterval methode. Lange (ontwikkel) trajecten, onvolledige en/of verouderde documentatie als ook een vast te volgen plan hebben allemaal een negatieve invloed op het eindproduct. Agile ontwikkeling richt zich voor als voornaamste taak op het leveren van een eindproduct waar de klant tevreden over is. Agile projecten trachten dit te bereiken doro het ontwikkelproces te benaderen met een proactieve houding naar de klant toe, als ook een dynamische en "open voor verandering" - mentaliteit.
						</p>
					</article>

					<article>
						<h3>Agile</h3>
						<p>
							In februari 2001 kwamen 17 prominenten op het terrein van Agile-ontwikkeling bijeen. De groep stelde het Agile Manifest [KMA] op, waarnaar puristische Agile-ontwikkelaars nog altijd graag verwijzen. Enkele principes uit het Manifest:
						</p>
						<ul>
							<li>Klanttevredenheid door snelle levering van bruikbare software op continue basis</li>
							<li>Regelmatig aanbod van nieuwe werkende software (eerder per week dan per maand)</li>
							<li>Wijziging van doelstellingen zijn welkom, zelfs laat in het proces.</li>
							<li>Nauwe samenwerking op dagelijkse basis tussen ontwikkelaars en hun belanghebbenden</li>
							<li>Direct persoonlijk contact</li>
							<li>Eenvoud</li>
							<li>Zelf-organiserende teams</li>
							<li>Voortdurende aanpassing aan veranderende omstandigheden</li>
						</ul>
						<p>
							Agile ontwikkelingsmethoden zijn al veel ouder dan het manifest. Zo kent Scrum - een bekende Agile methode met vaste samenstelling bestaande uit een projectleider, een projecteigenaar en een team - zijn wetenschappelijke 'comming out' in 1986. Extreme Programming en DSDM zijn van medio jaren negentig, toen deze nog bekend stonden als 'light-weight-methods'.
						</p>
					</article>

					<article>
						<h4>Contra Waterval</h4>
						<p>
							Alle varianten van Agile methodes zetten zich af tegen het 'waterval-ontwikkelmodel'. Een model dat bestaat uit vast omlijnde fases waarbij het hoogste niveau als eerste wordt uitgevoerd en daarna de lagere - gelijk een waterval. Een model dat oorspronkelijk zou afkosmtig zijn uit de bouwsector, waar aanpassingen naderhand prijzig, zo niet onmogelijk zijn.
						</p>
						<p>
							Dit watervalmodel - dat pas naar een volgende fase gaat als de vorige is afgesloten - zou te bindend zijn, te log en te bureaucratisch (veel papierwerk!). In tegenstelling tot de Agile methodes, die rekening kunnen houden met veranderende doelstellingen en zich bevrijden van bureaucratie door de nadruk op persoonlijk contact.
						</p>
						<p>
							Tegelijkertijd lijkt dat ook de zwakte van Agile ontwikkeling, als plannen telkens veranderen en communicatie niet in documenten vastligt, ligt de weg open naar willekeur en chaos. Daarom moet er een organisatie staan die past bij de Agile methode: een open, communicatieve cultuur waarin competente mensen het vertrouwen krijgen om beslissingen te nemen.
						</p>
					</article>

					<article>
						<h2>(Rational) Unified Proces</h2>
						<p>
							Een vorm van Agile ontwikkeling is het Rational Unified Proces (kortweg RUP). Deze methode is gebasseerd op onderstaande best practices:
						</p>
						<ol>
							<li>
								<b>Ontwikkel software iteratief</b>: ontwikkelen in korte overzichtelijke perioden genaamd iteraties. Binnen de iteraties hebben de klassieke activiteiten zoals: planning, analyse, ontwerp, testen en documentatie allemaal een plaats zij het gericht op de omvang van de iteratie zelf. Een Agile project team bestaat dan ook uit personen die elke gespecialiseerd zijn in een van deze vaardigheden.
							</li>
							<li>
								<b>Ontwikkel software incrementeel</b>: zorg dat je na elke iteratie een werkend product aflevert. Naast de risico's te verminderen (er kan een volledig systeem getest worden), wordt ook aan de klant dan een deel van het product geleverd die direct gebruikt kan worden. Die kan dan ook zijn opmerkingen onmiddelijk meegeven. Dit verkleint het risico dat het eindproduct neit is wat de klant wil en de klant kan nu per deelproduct zijn feedback geven wat je weer kunt meenemen tijdens de ontwikkeling van het volgende deelproduct. De fasen worden herhaaldelijk doorlopen.
							</li>
						</ol>
						<p>
							Daarnaast worden nog enkele raadgevingen meegegeven aan de mensen in het project:
						</p>
						<ul>
							<li>
								<b>Maak gebruik van componenten gebasseerde architectuur</b>: Systemen met een componenten gebasseerde architectuur zijn eenvoudig uit te breiden, inzichtelijk, begrijpelijk en bevorderen het hergebruik van bepaalde delen code. Aangezien de systemen steeds groter worden neemt het belang van een goede architectuur toe. RUP is erop gericht de basisarchitectuur in een vroeg stadium te bepalen, en naarmate het systeem groter wordt zal de architectuur zich verder uitbreiden. Bij iteratief ontwikkelen is het mogelijk de componenten geleidelijk in kaart te brengen om ze vervolgens te ontwikkelen, te kopen of te hergebruiken. 
							</li>
							<li>
								<b>Maak gebruik van prototypes</b>: Door de gebruiker een grafische voorstelling te geven van het product (prototyping), verkleint de faalkans van het project. Een globale, grafische oplossing voor het probleem is voor de gebruiker beter te begrijpendan pagina's vol broncode. Het is een versimpeling van de complexiteit. Naast prototypes komen in deze fase ook use cases, use case diagrammen, klassendiagrammen en andere objecten naar voren.
							</li>
							<li>
								<b>Test het systeem</b>: Het bepalen van de kwaliteit van een systeem gebeurt op basis van testen. Dit is een van de punten waarop software projecten vaak falen omdat het testen vaak aan het einde van het project wordt gedaan, soms helemaal niet en soms door andere teams. RUP vangt dit probleem af door het testen in het gehele proces terug te laten komen en daarbij alle belanghebbende (stakdeholders) te betrekken (zowel programmeurs als klanten). RUP gaat er vanuit dat elke belanghebbende verantwoordelijk is voor de kwaliteit gedurende het gehele project.
							</li>
							<li>
								<b>Maak gebruik van versiebeheer tijdens de softwareontwikkeling</b>: Zoals bij alle andere softwarepojecten zijn veranderingen in de software onvermijdelijk. RUP beschrijft een aantal methoden om deze veranderingen te beheersen en nauwkeurig te volgen. RUP beschrijft ook beveiligde werkruimtes, hierin staat bijvoorbeeld dat het systeem van een programmeur niet aangetast mag worden door veranderingen in een ander systeem.
							</li>
						</ul>
					</article>

					<article>
						<h2>Object ge&ouml;ri&euml;nteerde analyse</h2>
						<p>
							OOP streeft er naar om een project zo structureel mogelijk op te bouwen in objecten en klassen. Dit heeft voor de programmeur het grote voordeel dat code vanaf nu in logische componenten wordt opgedeeld en veel makkelijker te hergebruiken is.
						</p>
						<p>
							Om het concept van objecten te illustreren kan je bijvoorbeeld denken aan een auto Audi A4. De auto is het object en dit object heeft bepaalde eigenschappen. Een eigenschap van de auto kan bv de kleur, zetelbekleding, ... zijn. Een auto heeft ook een aantal onderdelen waaruit het bestaat, die ook voorgesteld kunnen worden als object. Denk hierbij maar aan deur, een band, ... Maar een auto heeft ook functies. Een functie kan starten of remmen zijn. Dus hebben we nu eigenlijk een object met eigenschappen en functies die in relatie kan staan met andere objecten? Het is op deze manier dat we ons modellering gaan toepassen.
						</p>
						<p>
							<b>Definite</b><em>: In een object geori&euml;nteerde methodologie worden zaken beschreven aan de hand van klassen. Klassen bevatten eigenschappen en methoden/functies. Een instantie van een dergelijke klasse is een object: het bevat de concrete waarden voor de eigenschappen van zijn klasse en heeft mogelijkheid de methoden en functies uit te voeren.</em>
						</p>
					</article>

					<article>
						<h2>UML</h2>
						<p>
							De Unified Modelling Language (UML) is een taal om diagrammen te maken of een notatiewijze om modellen van objectgeori&euml;nteerde softwaresystemen te specificeren, te visualiseren en te documenteren. UML is geen ontwikkelmethode, d.w.z. het vertelt je niet wat je eerst moet doen en wat daarna, of hoe je systeem moet ontwerpen, maar het helpt je om je systeem te visualiseren te communiceren met anderen. UML staat onder toezicht van de Object Management Group (OMG) en is de industriestandaard voor het grafisch weergeven van software.
						</p>
						<p>
							UML is opgebouwd uit vele modelelementen die de verschillende delen van een softwaresysteem vertegenwoordigen. De UML-elementen worden gebruikt om diagrammen te maken, die een bepaald deel of gezichtspunt van een systeem voorstellen.
						</p>
					</article>

					<article>
						<h3>Diagrammen</h3>
						<p>
							In wat volgt introduceren we de diagrammen die we zullen gebruiken doorheen de cursus:
							<ul>
								<li>
									<h4><b>Use Case - diagrammen</b></h4>
									<p>
										Use Case - diagrammen beschrijven de relaties en afhankelijkheden tussen een groep van use cases en de actoren die deelnemen aan het proces.
									</p>
									<p>
										Belangrijk om op te merken is dat use case-diagrammen niet geschikt zijn om het ontwerp te representeren, en niet het inwendige van een systeem kunnen beschrijven. Use case-diagrammen zijn bedoeld om de communicatie met de toekomstige gebruikers van een systeem, en met de klant, te vergemakkelijken, en zijn in het bijzonder behulpzaam bij het vaststellen van welke benodigde kenmerken een systeem moet hebben. Use case - diagrammen vertellen wat het systeem moet doen maar specificeren niet - en kunnen dat ook niet - hoe dit geraliseerd moet worden. 
									</p>
								</li>
							</ul>
						</p>
					</article>
			</section>

			<ol class="breadcrumb">
				<li><a href="analyse_I.html">Analyse I</a></li>
				<li class="active">De software crisis</li>
			</ol>
		<div>
	</body>
</html>